/**\n * ‚úÖ ARCHIVO CORREGIDO: src/services/expertApplicationService-fixed.ts\n * \n * Este archivo REEMPLAZA los datos mock con queries reales a Supabase.\n * Usar en lugar de: src/services/expertApplicationService.ts\n * \n * CAMBIOS PRINCIPALES:\n * - Remover todos los datos hardcoded (l√≠neas 167-280)\n * - Agregar funciones que llaman Supabase realmente\n * - Generar insights din√°micamente basado en datos reales\n */\n\nimport { supabaseClient } from '@/lib/supabase';\n\nexport interface Lead {\n  id: string;\n  title: string;\n  description: string;\n  status: 'pending' | 'active' | 'completed' | 'closed';\n  assigned_expert_id?: string;\n  user_id: string;\n  amount?: number;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface ExpertMetrics {\n  totalLeads: number;\n  activeLeads: number;\n  completedLeads: number;\n  totalEarnings: number;\n  completionRate: number;\n  avgResponseTime?: number;\n}\n\n/**\n * ‚úÖ OBTENER LEADS REALES DE UN EXPERTO\n * Reemplaza el array mock de l√≠nea 167\n */\nexport async function getExpertLeads(\n  expertId: string,\n  options?: {\n    status?: string;\n    limit?: number;\n    offset?: number;\n  }\n): Promise<Lead[]> {\n  try {\n    let query = supabaseClient\n      .from('leads')\n      .select('*')\n      .eq('assigned_expert_id', expertId);\n\n    // Filter by status if provided\n    if (options?.status) {\n      query = query.eq('status', options.status);\n    }\n\n    // Pagination\n    if (options?.limit) {\n      const offset = options?.offset || 0;\n      query = query.range(offset, offset + options.limit - 1);\n    }\n\n    // Sort by most recent\n    query = query.order('created_at', { ascending: false });\n\n    const { data, error } = await query;\n\n    if (error) {\n      console.error('[ExpertService] Error fetching leads:', error);\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('[ExpertService] getExpertLeads failed:', error);\n    throw error;\n  }\n}\n\n/**\n * ‚úÖ CALCULAR M√âTRICAS REALES\n * Reemplaza el objeto mock de l√≠nea 247\n */\nexport async function calculateExpertMetrics(\n  expertId: string\n): Promise<ExpertMetrics> {\n  try {\n    // Obtener todos los leads\n    const allLeads = await getExpertLeads(expertId);\n\n    // Calcular m√©tricas\n    const totalLeads = allLeads.length;\n    const activeLeads = allLeads.filter((l) => l.status === 'active').length;\n    const completedLeads = allLeads.filter(\n      (l) => l.status === 'completed'\n    ).length;\n\n    // Calcular ingresos totales\n    const totalEarnings = allLeads\n      .filter((l) => l.status === 'completed')\n      .reduce((sum, lead) => sum + (lead.amount || 0), 0);\n\n    // Calcular tasa de completaci√≥n\n    const completionRate =\n      totalLeads > 0 ? (completedLeads / totalLeads) * 100 : 0;\n\n    // Calcular tiempo promedio de respuesta (si existe en datos)\n    let avgResponseTime: number | undefined = undefined;\n    if (allLeads.length > 0) {\n      const responseTimes = allLeads\n        .filter((l) => l.updated_at && l.created_at)\n        .map((l) => {\n          const created = new Date(l.created_at).getTime();\n          const updated = new Date(l.updated_at!).getTime();\n          return (updated - created) / 1000 / 60; // Minutes\n        });\n\n      if (responseTimes.length > 0) {\n        avgResponseTime =\n          responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;\n      }\n    }\n\n    return {\n      totalLeads,\n      activeLeads,\n      completedLeads,\n      totalEarnings,\n      completionRate,\n      avgResponseTime,\n    };\n  } catch (error) {\n    console.error('[ExpertService] calculateExpertMetrics failed:', error);\n    // Return zero metrics instead of throwing\n    return {\n      totalLeads: 0,\n      activeLeads: 0,\n      completedLeads: 0,\n      totalEarnings: 0,\n      completionRate: 0,\n    };\n  }\n}\n\n/**\n * ‚úÖ GENERAR INSIGHTS DIN√ÅMICOS\n * Reemplaza el array mock de l√≠nea 268\n */\nexport function generateDynamicInsights(metrics: ExpertMetrics): string[] {\n  const insights: string[] = [];\n\n  // Insight 1: Status general\n  if (metrics.totalLeads === 0) {\n    insights.push(\n      'üöÄ ¬°Comienza! A√∫n no tienes leads. Actualiza tu perfil para que los clientes te encuentren.'\n    );\n  } else if (metrics.activeLeads === 0) {\n    insights.push(\n      'üì≠ No tienes leads activos en este momento. Considera publicar contenido o actualizar tu disponibilidad.'\n    );\n  } else {\n    insights.push(\n      `üìä Tienes ${metrics.activeLeads} lead${metrics.activeLeads !== 1 ? 's' : ''} activo${metrics.activeLeads !== 1 ? 's' : ''} esperando tu atenci√≥n.`\n    );\n  }\n\n  // Insight 2: Tasa de completaci√≥n\n  if (metrics.completionRate < 50 && metrics.totalLeads > 3) {\n    insights.push(\n      `‚ö†Ô∏è  Tu tasa de completaci√≥n es ${metrics.completionRate.toFixed(0)}%. Intenta mejorarla respondiendo m√°s r√°pido.`\n    );\n  } else if (metrics.completionRate >= 80) {\n    insights.push(\n      `‚ú® ¬°Excelente! Tu tasa de completaci√≥n es ${metrics.completionRate.toFixed(0)}%. Sigue as√≠.`\n    );\n  }\n\n  // Insight 3: Ingresos\n  if (metrics.totalEarnings > 0) {\n    const avgEarnings = metrics.completedLeads > 0\n      ? metrics.totalEarnings / metrics.completedLeads\n      : 0;\n    insights.push(\n      `üí∞ Has ganado $${metrics.totalEarnings.toLocaleString()} completando ${metrics.completedLeads} lead${metrics.completedLeads !== 1 ? 's' : ''}.`\n    );\n  }\n\n  // Insight 4: Tiempo de respuesta\n  if (metrics.avgResponseTime !== undefined) {\n    if (metrics.avgResponseTime < 30) {\n      insights.push(\n        '‚ö° Respondes muy r√°pido (${Math.round(metrics.avgResponseTime)} min). Los clientes lo aprecian.'\n      );\n    } else if (metrics.avgResponseTime > 240) {\n      insights.push(\n        'üê¢ Tu tiempo de respuesta promedio es ${Math.round(metrics.avgResponseTime / 60)} horas. Considera responder m√°s r√°pido.'\n      );\n    }\n  }\n\n  // Insight 5: Llamado a acci√≥n\n  if (metrics.totalLeads > 0 && metrics.activeLeads > 0) {\n    insights.push('üëâ Revisa tus leads activos ahora mismo para responder r√°pido.');\n  }\n\n  return insights;\n}\n\n/**\n * ‚úÖ OBTENER DASHBOARD DATA COMPLETO\n * Combina todos los datos en una sola llamada\n */\nexport async function getExpertDashboardData(expertId: string) {\n  try {\n    const [leads, metrics] = await Promise.all([\n      getExpertLeads(expertId, { limit: 10 }), // √öltimos 10 leads\n      calculateExpertMetrics(expertId),\n    ]);\n\n    const insights = generateDynamicInsights(metrics);\n\n    return {\n      leads,\n      metrics,\n      insights,\n      lastUpdated: new Date().toISOString(),\n    };\n  } catch (error) {\n    console.error('[ExpertService] getExpertDashboardData failed:', error);\n    throw error;\n  }\n}\n\n/**\n * ‚úÖ CREAR NUEVO LEAD\n */\nexport async function createLead(\n  data: Omit<Lead, 'id' | 'created_at' | 'updated_at'>\n): Promise<Lead> {\n  try {\n    const { data: newLead, error } = await supabaseClient\n      .from('leads')\n      .insert([data])\n      .select()\n      .single();\n\n    if (error) throw error;\n    return newLead;\n  } catch (error) {\n    console.error('[ExpertService] createLead failed:', error);\n    throw error;\n  }\n}\n\n/**\n * ‚úÖ ACTUALIZAR STATUS DE LEAD\n */\nexport async function updateLeadStatus(\n  leadId: string,\n  status: Lead['status']\n): Promise<Lead> {\n  try {\n    const { data: updatedLead, error } = await supabaseClient\n      .from('leads')\n      .update({ status, updated_at: new Date().toISOString() })\n      .eq('id', leadId)\n      .select()\n      .single();\n\n    if (error) throw error;\n    return updatedLead;\n  } catch (error) {\n    console.error('[ExpertService] updateLeadStatus failed:', error);\n    throw error;\n  }\n}\n"
